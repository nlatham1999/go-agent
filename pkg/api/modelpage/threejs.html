<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    let scene, camera, renderer;
    let patchGroup, turtleGroup, linkGroup;
    let offsetX = 0, offsetY = 0;
    let patchSize = 1;
    let minPxCor = 0, minPyCor = 0, maxPxCor = 0, maxPyCor = 0;
    let animateTimeout = 16;

    // Shared geometries and materials for reuse (major performance improvement)
    let sharedGeometries = {
        plane: null,
        circle: null,
        triangle: null
    };

    // Object pools to reuse meshes instead of recreating
    let patchPool = [];
    let turtlePool = [];
    let linkPool = [];
    let spritePool = [];

    // Track current model state
    let lastModelData = null;

    function init() {
        if (renderer) {
            renderer.dispose();
            document.getElementById("threejs-container").innerHTML = ""; // clear old canvas
        }

        if (!document.createElement("canvas").getContext("webgl")) {
            console.error("WebGL is not supported in this browser.");
            alert("WebGL is not supported on your browser. Try enabling it or using another browser.");
        } else {
            console.log("WebGL is supported");
        }
        // Get screen dimensions
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;

        //right half of the screen
        let viewWidth = screenWidth * 0.5;

        // minus 1vw to have margin on the right
        viewWidth = viewWidth - (viewWidth * 0.01);

        // 1vh margin on top and bottom
        let viewHeight = screenHeight - (screenHeight * 0.02);

        // Create Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x008000); // Green background

        // Camera
        camera = new THREE.OrthographicCamera(
            -viewWidth, viewWidth, viewHeight, -viewHeight,  
            0.1, 1000
        );
        camera.position.set(0, 0, 100);
        camera.lookAt(0, 0, 0);

        // Renderer
        // renderer = new THREE.WebGLRenderer();
        renderer = new THREE.WebGLRenderer({ antialias: true });

        renderer.setSize(viewWidth, viewHeight);
        renderer.domElement.style.position = "absolute";
        renderer.domElement.style.left = "50vw";
        renderer.domElement.style.top = "1vh";
        renderer.domElement.style.border = "1px solid rgba(59, 130, 246, 0.4)";
        renderer.domElement.style.borderRadius = "12px";
        renderer.domElement.style.boxShadow = "0 8px 24px rgba(0, 0, 0, 0.2), 0 0 20px rgba(59, 130, 246, 0.2)";
        renderer.domElement.addEventListener("webglcontextlost", (event) => {
            event.preventDefault();
            console.warn("WebGL context lost! Restarting...");
            init();
        });

        // Append to correct div
        const container = document.getElementById("threejs-container");
        if (container) {
            container.appendChild(renderer.domElement);
        } else {
            console.error("Container not found!");
        }

        // Create mouse move event listener
        renderer.domElement.addEventListener('mousemove', function (event) {
            const rect = renderer.domElement.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            UpdateMouseMoved((x / patchSize) + minPxCor - .5, (y / patchSize * -1) + maxPyCor + .5);
        });

        // Create mouse click event listener
        renderer.domElement.addEventListener('click', function (event) {
            const rect = renderer.domElement.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            UpdateMouseClicked((x / patchSize) + minPxCor - .5, (y / patchSize * -1) + maxPyCor + .5);
        });

        // Groups to store objects
        patchGroup = new THREE.Group();
        turtleGroup = new THREE.Group();
        linkGroup = new THREE.Group();

        scene.add(patchGroup);
        scene.add(turtleGroup);
        scene.add(linkGroup);

        animate();
    }

    function animate() {
        renderer.render(scene, camera);
        setTimeout(animate, animateTimeout);
    }


    async function fetchDataAndUpdateScene() {

        let endpoint = "/model";

        if (document.getElementById("replayTick").value != "") {
            console.log("Replaying for tick:", document.getElementById("replayTick").value);
            endpoint = "/modelat?step=" + document.getElementById("replayTick").value;
        }

        try {
            const response = await fetch(endpoint);
            if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
            const model = await response.json();
            updateScene(model);
        } catch (error) {
            console.error("Error fetching simulation data:", error);
        } 
    }

    // Helper function to get or create a mesh from pool
    function getOrCreatePatch(index) {
        if (patchPool[index]) {
            patchPool[index].visible = true;
            return patchPool[index];
        }

        // Create shared geometry if needed
        if (!sharedGeometries.plane) {
            sharedGeometries.plane = new THREE.PlaneGeometry(1, 1);
        }

        const material = new THREE.MeshBasicMaterial();
        const mesh = new THREE.Mesh(sharedGeometries.plane, material);
        patchGroup.add(mesh);
        patchPool[index] = mesh;
        return mesh;
    }

    function getOrCreateTurtle(index, shape) {
        if (turtlePool[index] && turtlePool[index].userData.shape === shape) {
            turtlePool[index].visible = true;
            return turtlePool[index];
        }

        // Remove old turtle if shape changed
        if (turtlePool[index]) {
            turtleGroup.remove(turtlePool[index]);
            turtlePool[index].geometry.dispose();
            turtlePool[index].material.dispose();
        }

        let geometry, material, mesh;

        if (shape === 'circle') {
            if (!sharedGeometries.circle) {
                sharedGeometries.circle = new THREE.CircleGeometry(0.5, 32);
            }
            geometry = sharedGeometries.circle;
            material = new THREE.MeshBasicMaterial();
            mesh = new THREE.Mesh(geometry, material);
        } else if (shape === 'triangle') {
            geometry = new THREE.BufferGeometry();
            const vertices = new Float32Array([
                0.5, 0, 0,
                -0.5, -0.289, 0,
                -0.5, 0.289, 0
            ]);
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            material = new THREE.MeshBasicMaterial({ side: THREE.DoubleSide });
            mesh = new THREE.Mesh(geometry, material);
        }

        mesh.userData.shape = shape;
        turtleGroup.add(mesh);
        turtlePool[index] = mesh;
        return mesh;
    }

    function getOrCreateLink(index) {
        if (linkPool[index]) {
            linkPool[index].visible = true;
            return linkPool[index];
        }

        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(6); // 2 points * 3 coords
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const material = new THREE.LineBasicMaterial();
        const line = new THREE.Line(geometry, material);
        linkGroup.add(line);
        linkPool[index] = line;
        return line;
    }

    function getOrCreateSprite(index) {
        if (spritePool[index]) {
            spritePool[index].visible = true;
            return spritePool[index];
        }

        const canvas = document.createElement('canvas');
        canvas.width = 256;
        canvas.height = 256;
        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.SpriteMaterial({ map: texture, depthTest: false });
        const sprite = new THREE.Sprite(material);
        sprite.userData.canvas = canvas;
        sprite.userData.texture = texture;
        turtleGroup.add(sprite);
        spritePool[index] = sprite;
        return sprite;
    }

    function updateScene(model) {
        if (!patchGroup || !turtleGroup || !linkGroup) {
            console.error("Scene groups not initialized!");
            return;
        }

        // Hide all objects first (will show the ones we need)
        patchPool.forEach(p => p && (p.visible = false));
        turtlePool.forEach(t => t && (t.visible = false));
        linkPool.forEach(l => l && (l.visible = false));
        spritePool.forEach(s => s && (s.visible = false));


        // get the screen dimensions
        let screenWidth = window.innerWidth; // right half
        let screenHeight = window.innerHeight; // account for margins
        screenWidth = screenWidth / 2;
        screenWidth = screenWidth - (screenWidth * 0.01);

        // Calculate patch size
        let maxPatchWidth = screenWidth / model.width;
        let maxPatchHeight = screenHeight / model.height;
        patchSize = Math.min(maxPatchWidth, maxPatchHeight);

        // Update camera
        const halfWidth = (model.width * patchSize) / 2;
        const halfHeight = (model.height * patchSize) / 2;
        camera.left = -halfWidth;
        camera.right = halfWidth;
        camera.top = halfHeight;
        camera.bottom = -halfHeight;
        camera.updateProjectionMatrix();

        // Update renderer
        const aspectRatio = model.width / model.height;
        let viewWidth, viewHeight;
        if ( screenHeight / model.height > screenWidth /  model.width) {
            viewWidth = screenWidth;
            viewHeight = screenWidth / aspectRatio;
        } else {
            viewHeight = screenHeight;
            viewWidth = screenHeight * aspectRatio;
        }
        renderer.setSize(viewWidth, viewHeight);
        renderer.domElement.style.width = `${viewWidth}px`;
        renderer.domElement.style.height = `${viewHeight}px`;

        // set an offset to center the model
        offsetX = (model.maxPxCor + model.minPxCor) / 2;
        offsetY = (model.maxPyCor + model.minPyCor) / 2; 

        minPxCor = model.minPxCor;
        minPyCor = model.minPyCor;
        maxPxCor = model.maxPxCor;
        maxPyCor = model.maxPyCor;
        

        // Update Patches - reuse existing meshes
        model.patches.forEach((patch, index) => {
            const mesh = getOrCreatePatch(index);

            // Update color
            mesh.material.color.setRGB(patch.color.r / 255, patch.color.g / 255, patch.color.b / 255);

            // Update position and scale
            const relativeX = patch.x;
            const relativeY = patch.y;
            mesh.position.set((relativeX - offsetX) * patchSize, (relativeY - offsetY) * patchSize, 0);
            mesh.scale.set(patchSize, patchSize, 1);
        });

        // Update Turtles - reuse existing meshes
        let spriteIndex = 0;
        model.turtles.forEach((turtle, index) => {
            const mesh = getOrCreateTurtle(index, turtle.shape);

            // Update color
            mesh.material.color.setRGB(turtle.color.r / 255, turtle.color.g / 255, turtle.color.b / 255);

            // Update position
            const relativeX = turtle.x;
            const relativeY = turtle.y;
            const posX = (relativeX - offsetX) * patchSize;
            const posY = (relativeY - offsetY) * patchSize;
            mesh.position.set(posX, posY, 0.1);

            // Update scale based on size
            const size = turtle.size * patchSize;
            mesh.scale.set(size, size, 1);

            // Update rotation for triangles
            if (turtle.shape === 'triangle') {
                mesh.rotation.z = THREE.MathUtils.degToRad(turtle.heading);
            }

            // Handle labels
            if (turtle.label && turtle.label !== "") {
                const sprite = getOrCreateSprite(spriteIndex++);
                const canvas = sprite.userData.canvas;
                const ctx = canvas.getContext('2d');

                // Clear and redraw label
                ctx.clearRect(0, 0, 256, 256);
                ctx.font = '48px Arial';
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(turtle.label, 128, 128);

                sprite.userData.texture.needsUpdate = true;
                sprite.scale.set(patchSize * 1.5, patchSize * 1.5, 1);
                sprite.position.set(posX, posY, 0.2);
            }
        });

        // Update Links - reuse existing lines
        let linkIndex = 0;
        model.links.forEach((link) => {
            if (!link.hidden) {
                const line = getOrCreateLink(linkIndex++);

                // Update color
                line.material.color.setRGB(link.color.r / 255, link.color.g / 255, link.color.b / 255);

                // Update positions
                const positions = line.geometry.attributes.position.array;
                positions[0] = (link.end1X - offsetX) * patchSize;
                positions[1] = (link.end1Y - offsetY) * patchSize;
                positions[2] = 0.05;
                positions[3] = (link.end2X - offsetX) * patchSize;
                positions[4] = (link.end2Y - offsetY) * patchSize;
                positions[5] = 0.05;
                line.geometry.attributes.position.needsUpdate = true;
            }
        });
    }

    function UpdateMouseClicked(x, y) {

        const params = new URLSearchParams({
            "mouse-x-clicked": x,
            "mouse-y-clicked": y,
            "mouse-clicked": true  
        });

        fetch(`/updatedynamic?${params.toString()}`)
            .then(res => res.text())
            .then(data => console.log("Server response:", data))
            .catch(err => console.error("Error:", err));
    }

    function UpdateMouseMoved(x, y) {
        const params = new URLSearchParams({
            "mouse-x-moved": x,
            "mouse-y-moved": y,
            "mouse-moved": true  
        });

        fetch(`/updatedynamic?${params.toString()}`)
            .then(res => res.text())
            .then(data => console.log("Server response:", data))
            .catch(err => console.error("Error:", err));
    }

    // Initialize Three.js
    window.onload = init;

    let lastUpdateTime = 0;
    let isFetching = false;
    async function fetchAndRender() {
        const now = performance.now();
        if (!isFetching && now - lastUpdateTime >= 50) {
            isFetching = true;
            fetchDataAndUpdateScene();  // wait for fetch to finish
            lastUpdateTime = performance.now();
            isFetching = false;
        } else {
            console.log("Skipping frame...");
        }
        requestAnimationFrame(fetchAndRender);
    }
    requestAnimationFrame(fetchAndRender);

</script>