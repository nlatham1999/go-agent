<script>

    // Track widget structure to detect changes
    let currentWidgetStructure = null;

    // Store chart instances for updates
    let chartInstances = {};

    function getWidgetStructureHash(widgets) {
        // Create a hash of widget IDs and types to detect structural changes
        return widgets.map(w => `${w.id}:${w.widgetType}`).join('|');
    }

    // Widget rendering functions
    function renderWidget(widget) {
        const widgetDiv = document.createElement('div');
        widgetDiv.className = `widget widget-${widget.widgetType}`;
        widgetDiv.setAttribute('data-widget-index', widget.index);
        widgetDiv.setAttribute('data-widget-id', widget.id);

        const widgetId = `${widget.id}-widget`;

        if (widget.widgetType === 'text') {
            const label = document.createElement('label');
            label.setAttribute('for', widgetId);
            label.textContent = widget.prettyName;
            widgetDiv.appendChild(label);

            const input = document.createElement('input');
            input.type = 'text';
            input.id = widgetId;
            input.name = widget.id;
            input.setAttribute('hx-get', '/updatedynamic');
            input.setAttribute('hx-trigger', 'change');
            input.setAttribute('hx-include', `#${widgetId}`);
            input.value = widget.currentValue || widget.defaultValue || '';
            widgetDiv.appendChild(input);
        } else if (widget.widgetType === 'slider') {
            const labelDiv = document.createElement('div');
            const label = document.createElement('label');
            label.setAttribute('for', widgetId);

            const labelId = `${widgetId}-label`;
            const valueSpan = document.createElement('span');
            valueSpan.id = labelId;
            valueSpan.textContent = widget.currentValue || widget.defaultValue;

            label.textContent = `${widget.prettyName}: `;
            label.appendChild(valueSpan);
            labelDiv.appendChild(label);
            widgetDiv.appendChild(labelDiv);

            const input = document.createElement('input');
            input.type = 'range';
            input.id = widgetId;
            input.name = widget.id;
            input.min = widget.minValue;
            input.max = widget.maxValue;
            input.value = widget.currentValue || widget.defaultValue;
            if (widget.stepAmount) {
                input.step = widget.stepAmount;
            }
            input.setAttribute('hx-get', '/updatedynamic');
            input.setAttribute('hx-trigger', 'change');
            input.setAttribute('hx-include', `#${widgetId}`);
            input.oninput = function() {
                document.getElementById(labelId).textContent = this.value;
            };
            widgetDiv.appendChild(input);
        } else if (widget.widgetType === 'button') {
            const button = document.createElement('button');
            button.id = widgetId;
            button.textContent = widget.prettyName;
            button.setAttribute('hx-swap', 'none');
            button.setAttribute('hx-get', '/updatedynamic');
            button.setAttribute('hx-trigger', 'click');
            button.setAttribute('hx-vals', `{"${widget.id}": "test"}`);
            widgetDiv.appendChild(button);
        } else if (widget.widgetType === 'stat') {
            const statDiv = document.createElement('div');
            statDiv.id = widget.id;
            statDiv.textContent = `${widget.prettyName}: ${widget.currentValue}`;
            widgetDiv.appendChild(statDiv);
        } else if (widget.widgetType === 'graph') {
            // Parse graph data from JSON
            let graphData;
            try {
                graphData = JSON.parse(widget.currentValue);
                console.log('Parsed graph data:', graphData);
            } catch (e) {
                console.error('Failed to parse graph data:', e, 'Raw value:', widget.currentValue);
                const errorDiv = document.createElement('div');
                errorDiv.textContent = `Error parsing graph: ${widget.prettyName}`;
                errorDiv.style.color = '#ef4444';
                widgetDiv.appendChild(errorDiv);
                return widgetDiv;
            }

            // Create container for the graph
            const graphContainer = document.createElement('div');
            graphContainer.style.width = '100%';
            graphContainer.style.height = '300px';
            graphContainer.style.position = 'relative';

            // Create canvas for chart
            const canvas = document.createElement('canvas');
            canvas.id = `${widget.id}-canvas`;
            canvas.style.display = 'block';

            graphContainer.appendChild(canvas);
            widgetDiv.appendChild(graphContainer);

            // Store graph data for later chart creation
            widgetDiv.dataset.graphData = JSON.stringify(graphData);
        }

        return widgetDiv;
    }

    function createOrUpdateChart(widgetId, graphData) {
        console.log('createOrUpdateChart called for', widgetId, 'with data:', graphData);

        // Check if Chart.js is loaded
        if (typeof Chart === 'undefined') {
            console.error('Chart.js is not loaded!');
            return;
        }

        const canvasId = `${widgetId}-canvas`;
        const canvas = document.getElementById(canvasId);
        if (!canvas) {
            console.error('Canvas not found for', canvasId, 'Available canvases:',
                Array.from(document.querySelectorAll('canvas')).map(c => c.id));
            return;
        }

        console.log('Canvas found:', canvas, 'Size:', canvas.width, 'x', canvas.height);

        // Convert string arrays to numbers for Y values
        const yValues = graphData.yValues.map(v => parseFloat(v));
        console.log('Y values:', yValues);

        // If chart already exists, update it
        if (chartInstances[widgetId]) {
            console.log('Updating existing chart for', widgetId);
            const chart = chartInstances[widgetId];
            chart.data.labels = graphData.xValues;
            chart.data.datasets[0].data = yValues;
            chart.options.plugins.title.text = graphData.title;
            chart.update('none'); // Update without animation for performance
            return;
        }

        console.log('Creating new chart for', widgetId);

        // Create new chart
        const ctx = canvas.getContext('2d');
        const chart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: graphData.xValues || [],
                datasets: [{
                    label: graphData.yLabel || 'Value',
                    data: yValues,
                    borderColor: '#3b82f6',
                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                    borderWidth: 2,
                    tension: 0.3,
                    fill: true,
                    pointRadius: 3,
                    pointHoverRadius: 5
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false, // Disable animation for performance
                plugins: {
                    legend: {
                        display: true,
                        labels: {
                            color: '#cbd5e1',
                            font: {
                                family: '"Space Mono", monospace',
                                size: 11
                            }
                        }
                    },
                    title: {
                        display: !!graphData.title,
                        text: graphData.title || '',
                        color: '#f1f5f9',
                        font: {
                            size: 16,
                            weight: 'bold',
                            family: '"Space Mono", monospace'
                        },
                        padding: {
                            top: 10,
                            bottom: 15
                        }
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: !!graphData.xLabel,
                            text: graphData.xLabel || '',
                            color: '#cbd5e1',
                            font: {
                                size: 12,
                                family: '"Space Mono", monospace'
                            }
                        },
                        ticks: {
                            color: '#94a3b8',
                            maxTicksLimit: 10,
                            font: {
                                size: 10,
                                family: '"Space Mono", monospace'
                            }
                        },
                        grid: {
                            color: 'rgba(203, 213, 225, 0.1)'
                        }
                    },
                    y: {
                        title: {
                            display: !!graphData.yLabel,
                            text: graphData.yLabel || '',
                            color: '#cbd5e1',
                            font: {
                                size: 12,
                                family: '"Space Mono", monospace'
                            }
                        },
                        ticks: {
                            color: '#94a3b8',
                            font: {
                                size: 10,
                                family: '"Space Mono", monospace'
                            }
                        },
                        grid: {
                            color: 'rgba(203, 213, 225, 0.1)'
                        },
                        beginAtZero: true
                    }
                }
            }
        });

        chartInstances[widgetId] = chart;
        console.log('Chart created successfully for', widgetId, 'Chart instance:', chart);
    }

    function loadWidgets() {
        fetch('/widgets')
            .then(response => response.json())
            .then(widgets => {
                console.log('Loaded widgets:', widgets);

                // Find graph widgets
                const graphWidgets = widgets.filter(w => w.widgetType === 'graph');
                console.log('Graph widgets:', graphWidgets);

                // Initialize structure tracking
                currentWidgetStructure = getWidgetStructureHash(widgets);

                const container = document.getElementById('widgetContainer');
                container.innerHTML = '';

                widgets.forEach(widget => {
                    const widgetElement = renderWidget(widget);
                    container.appendChild(widgetElement);
                });

                // Re-initialize HTMX for new elements
                if (window.htmx) {
                    htmx.process(container);
                }

                // Apply widget positions and dragging
                initWidgetDragging();
                applyWidgetPositions();

                // Create charts for all graph widgets after DOM is ready
                setTimeout(() => {
                    console.log('Creating charts after timeout...');
                    const graphDivs = document.querySelectorAll('.widget-graph');
                    console.log('Found graph divs:', graphDivs.length);

                    graphDivs.forEach(widgetDiv => {
                        const widgetId = widgetDiv.getAttribute('data-widget-id');
                        const graphDataStr = widgetDiv.dataset.graphData;
                        console.log('Processing graph widget:', widgetId, 'Data:', graphDataStr);

                        if (graphDataStr) {
                            try {
                                const graphData = JSON.parse(graphDataStr);
                                createOrUpdateChart(widgetId, graphData);
                            } catch (e) {
                                console.error('Failed to create chart for', widgetId, e);
                            }
                        } else {
                            console.error('No graph data found for', widgetId);
                        }
                    });
                }, 100);
            })
            .catch(error => console.error('Error loading widgets:', error));
    }

    const goRepeatText = document.getElementById('goRepeat').innerText;

    const goOnceButton = document.getElementById('goOnce');
    const goRepeatButton = document.getElementById('goRepeat');
    const replayTickContainer = document.getElementById('replayTick');
    const replayTick = document.getElementById('replayTick');
    const loadButton = document.getElementById('loadButton');
    const setupButton = document.getElementById('setup');
    const contentDiv = document.getElementById('content');

    // Function to update visibility based on goRepeatButton's inner text
    function updateVisibility() {
        if (goRepeatButton.innerText === '\u00A0\u00A0\u00A0Pause\u00A0\u00A0\u00A0') {
            // replayTickContainer.setAttribute('disabled', true);
            replayTick.disabled = true;
        } else {
            // replayTickContainer.setAttribute('disabled', false);
            replayTick.disabled = false;
        }
    }

    // Add an event listener to the goRepeat button to change text and update visibility
    goRepeatButton.addEventListener('click', function() {
        if (document.getElementById('goRepeat').innerText == goRepeatText) {
            document.getElementById('goRepeat').innerText = '\u00A0\u00A0\u00A0Pause\u00A0\u00A0\u00A0\u00A0';
        } else {
            document.getElementById('goRepeat').innerText = goRepeatText;
        }
        updateVisibility();
    });

    setupButton.addEventListener('click', function() {
        goRepeatButton.innerText = goRepeatText;
    })

    // Initial check on page load
    updateVisibility();

    // event listener on go to make the tickValue current
    goOnceButton.addEventListener('click', function() {
        tickValue = 'current';
    });

    // event listener on go to make the tickValue current
    goRepeatButton.addEventListener('click', function() {
        tickValue = 'current';
    });

    let savedScrollPosition = 0;

    // loadButton.addEventListener('htmx:beforeRequest', function() {
    //     // Save the current scroll position before the content is refreshed
    //     statsContainer = document.getElementById('statsContainer');
    //     savedScrollPosition = statsContainer.scrollTop;
    //     console.log('Saved scroll position:', savedScrollPosition);
    // });

    // contentDiv.addEventListener('htmx:afterSwap', function() {
    //     // Restore the saved scroll position after the content is updated
    //     statsContainer = document.getElementById('statsContainer');
    //     statsContainer.scrollTop = savedScrollPosition;
    //     console.log('Restored scroll position:', savedScrollPosition);
    // });

    // Widget dragging with position persistence
    let dragState = {
        isDragging: false,
        currentWidget: null,
        offsetX: 0,
        offsetY: 0
    };

    // Load saved widget positions from localStorage
    function loadWidgetPositions() {
        const saved = localStorage.getItem('widgetPositions');
        return saved ? JSON.parse(saved) : {};
    }

    // Save widget positions to localStorage
    function saveWidgetPosition(widgetId, left, top) {
        const positions = loadWidgetPositions();
        positions[widgetId] = { left, top };
        localStorage.setItem('widgetPositions', JSON.stringify(positions));
    }

    // Apply saved positions to widgets or set default positions
    function applyWidgetPositions() {
        const positions = loadWidgetPositions();
        document.querySelectorAll('.widget').forEach(widget => {
            const widgetId = getWidgetId(widget);
            if (positions[widgetId]) {
                // Apply saved position
                widget.style.left = positions[widgetId].left + 'px';
                widget.style.top = positions[widgetId].top + 'px';
            } else {
                // Set default position based on widget index
                const index = parseInt(widget.getAttribute('data-widget-index') || 0);
                widget.style.left = '0px';
                widget.style.top = (index * 65) + 'px';
            }
        });
    }

    // Get unique widget ID
    function getWidgetId(widget) {
        // Use the input/button ID inside the widget as unique identifier
        const input = widget.querySelector('input, button');
        return input ? input.id : widget.className;
    }

    // Initialize dragging for all widgets
    function initWidgetDragging() {
        document.querySelectorAll('.widget').forEach(widget => {
            // Remove old listeners if any
            widget.onmousedown = null;

            widget.addEventListener('mousedown', (e) => {
                // Prevent dragging when interacting with inputs, buttons, or sliders
                if (e.target.tagName === 'TEXTAREA' ||
                    e.target.tagName === 'INPUT' ||
                    e.target.tagName === 'BUTTON') {
                    return;
                }

                dragState.isDragging = true;
                dragState.currentWidget = widget;
                dragState.offsetX = e.clientX - widget.offsetLeft;
                dragState.offsetY = e.clientY - widget.offsetTop;
                widget.style.cursor = 'grabbing';
                widget.style.zIndex = '1000';
                widget.style.transition = 'none'; // Disable transition during drag
                e.preventDefault();
            });
        });
    }

    // Global mouse move handler for instant dragging
    document.addEventListener('mousemove', (e) => {
        if (!dragState.isDragging || !dragState.currentWidget) return;

        const newLeft = e.clientX - dragState.offsetX;
        const newTop = e.clientY - dragState.offsetY;
        dragState.currentWidget.style.left = newLeft + 'px';
        dragState.currentWidget.style.top = newTop + 'px';
    });

    // Global mouse up handler
    document.addEventListener('mouseup', () => {
        if (dragState.isDragging && dragState.currentWidget) {
            dragState.currentWidget.style.cursor = 'move';
            dragState.currentWidget.style.zIndex = '';
            dragState.currentWidget.style.transition = ''; // Re-enable transition

            // Save position
            const widgetId = getWidgetId(dragState.currentWidget);
            saveWidgetPosition(
                widgetId,
                parseInt(dragState.currentWidget.style.left),
                parseInt(dragState.currentWidget.style.top)
            );

            dragState.isDragging = false;
            dragState.currentWidget = null;
        }
    });

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', () => {
        console.log('DOM loaded. Chart.js available:', typeof Chart !== 'undefined');
        if (typeof Chart !== 'undefined') {
            console.log('Chart.js version:', Chart.version);
        }
        loadWidgets();
    });

    // Periodically reload widgets to get updated values from server
    function startWidgetSync() {
        setInterval(() => {
            fetch('/widgets')
                .then(response => response.json())
                .then(widgets => {
                    const newStructure = getWidgetStructureHash(widgets);

                    // Check if widget structure has changed (widgets added/removed/changed type)
                    if (currentWidgetStructure !== newStructure) {
                        console.log('Widget structure changed, reloading widgets...');
                        currentWidgetStructure = newStructure;

                        // Destroy old chart instances to prevent memory leaks
                        Object.values(chartInstances).forEach(chart => {
                            if (chart) chart.destroy();
                        });
                        chartInstances = {};

                        // Full reload of widgets
                        const container = document.getElementById('widgetContainer');
                        container.innerHTML = '';

                        widgets.forEach(widget => {
                            const widgetElement = renderWidget(widget);
                            container.appendChild(widgetElement);
                        });

                        // Re-initialize HTMX for new elements
                        if (window.htmx) {
                            htmx.process(container);
                        }

                        // Apply widget positions and dragging
                        initWidgetDragging();
                        applyWidgetPositions();

                        // Create charts for all graph widgets after DOM is ready
                        setTimeout(() => {
                            document.querySelectorAll('.widget-graph').forEach(widgetDiv => {
                                const widgetId = widgetDiv.getAttribute('data-widget-id');
                                const graphDataStr = widgetDiv.dataset.graphData;
                                if (graphDataStr) {
                                    try {
                                        const graphData = JSON.parse(graphDataStr);
                                        createOrUpdateChart(widgetId, graphData);
                                    } catch (e) {
                                        console.error('Failed to create chart for', widgetId, e);
                                    }
                                }
                            });
                        }, 100);

                        return;
                    }

                    // Structure hasn't changed, just update values
                    widgets.forEach(widget => {
                        const widgetElement = document.querySelector(`[data-widget-id="${widget.id}"]`);
                        if (!widgetElement) return;

                        const widgetId = `${widget.id}-widget`;

                        // Update stat values
                        if (widget.widgetType === 'stat') {
                            const statDiv = document.getElementById(widget.id);
                            if (statDiv) {
                                statDiv.textContent = `${widget.prettyName}: ${widget.currentValue}`;
                            }
                        }

                        // Update graph values
                        if (widget.widgetType === 'graph') {
                            try {
                                const graphData = JSON.parse(widget.currentValue);
                                createOrUpdateChart(widget.id, graphData);
                            } catch (e) {
                                console.error('Failed to parse graph data during sync:', e);
                            }
                        }

                        // Update slider/input values if they've changed server-side
                        if (widget.widgetType === 'slider' || widget.widgetType === 'text') {
                            const input = document.getElementById(widgetId);
                            const label = document.getElementById(`${widgetId}-label`);

                            // Only update if user isn't actively changing it
                            if (input && document.activeElement !== input) {
                                input.value = widget.currentValue || widget.defaultValue;
                                if (label) {
                                    label.textContent = widget.currentValue || widget.defaultValue;
                                }
                            }
                        }
                    });
                })
                .catch(error => console.error('Error syncing widgets:', error));
        }, 500); // Sync every 500ms
    }

    // Start syncing after initial load
    document.addEventListener('DOMContentLoaded', () => {
        startWidgetSync();
    });

    // if goOnce is clicked, set replayTick to empty string
    goOnceButton.addEventListener('click', function() {
        replayTick.value = '';
    });

    // if goRepeat is clicked, set replayTick to empty string
    goRepeatButton.addEventListener('click', function() {
        replayTick.value = '';
    });

    // if setup is clicked, set replayTick to empty string
    setupButton.addEventListener('click', function() {
        replayTick.value = '';
    });


</script>